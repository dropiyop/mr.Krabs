from datetime import  date
from playwright.async_api import async_playwright
import asyncio
from aiog import *
import re
import editabs
import init_clients
from simple_tg_md import convert_to_md2
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path
import os
from main import logger
import platform

def load_keywords(filepath: str = r"keywords") -> list[str]:
    with open(filepath, "r", encoding="utf-8") as f:
        return [line.strip() for line in f if line.strip()]

def load_prompt(filename: str = "prompt.txt") -> list[str]:
    # –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ –∫–æ—Ä–Ω—é –ø—Ä–æ–µ–∫—Ç–∞
    current_file = Path(__file__)
    project_root = current_file.parent.parent  # handlers/../
    filepath = project_root / filename

    if not filepath.exists():
        raise FileNotFoundError(f"–§–∞–π–ª {filepath} –Ω–µ –Ω–∞–π–¥–µ–Ω")

    with open(filepath, "r", encoding="utf-8") as f:
        return [line.strip() for line in f if line.strip()]

prompt = load_prompt("prompt.txt")

def filter_by_today_date(notices):
    """–§–∏–ª—å—Ç—Ä—É–µ—Ç –∑–∞–ø–∏—Å–∏ —Ç–æ–ª—å–∫–æ –ø–æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–π –¥–∞—Ç–µ"""
    today = datetime.now().strftime("%d.%m.%Y")
    today_notices = []


    for notice in notices:
        pub_date = notice.get('pub_date', '')
        if pub_date == today:
            today_notices.append(notice)


    return today_notices



async def filter_notices(notices, keywords):
    """–§–∏–ª—å—Ç—Ä—É–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º –∏ –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º –∏ —Å—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤ –¢–ì"""
    sent_count = 0
    filtered_notices = []

    for notice in notices:
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞
        search_text = f"{notice.get('name', '')} {notice.get('uchr_sname', '')}"

        number = notice.get('number', '')
        if  editabs.check(number, fz=None):
            continue

        if number:
            editabs.save(number, fz=None)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
        if not any(keyword.lower() in search_text.lower() for keyword in keywords):
            continue
        else:
            # GPT-—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
            response = await init_clients.client_openai.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": f"{prompt}"
                 },
                {"role": "user", "content":  f"{notice}\n{keywords}" }
                ],
                temperature=0.2,
            )

            answer_gpt = response.choices[0].message.content.strip()
            if answer_gpt.lower() == '–Ω–µ—Ç':
                logger.info(f"–ó–∞–∫—É–ø–∫–∞ {number} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ GPT")
                continue


            filtered_notices.append(notice)
            sent_count += 1

    return filtered_notices, sent_count



async def send_notifications(notice):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ–¥–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
    users_data = editabs.get_client_users()
    success_count = 0

    for user_data in users_data:
        chat_id = user_data[0] if isinstance(user_data, tuple) else user_data

        if not chat_id:
            continue

        try:
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É
            full_url = f"https://mimz.admoblkaluga.ru/GzwSP/Notice?noticeLink={notice['link']}"

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            text = f"""üîî –ù–æ–≤–∞—è –∑–∞–∫—É–ø–∫–∞ —Å —Å–∞–π—Ç–∞  –ú–ò–ú–ó
            
            üìù–ù–æ–º–µ—Ä:{convert_to_md2(notice.get('number', 'N/A'))}
            üìã–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ: {convert_to_md2(notice.get('name', 'N/A'))}
            """

            # –°–æ–∑–¥–∞–µ–º –∏–Ω–ª–∞–π–Ω –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
            markup = InlineKeyboardMarkup(
                inline_keyboard=[[InlineKeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å –∑–∞–∫—É–ø–∫—É", url=full_url)]]
                )

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await init_clients.bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=markup,
                parse_mode=aiogram.enums.ParseMode.MARKDOWN_V2
                )

            success_count += 1

            # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
            await asyncio.sleep(0.5)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–ª—è chat_id {chat_id}: {e}")



    return success_count


async def send_all_filtered_notices(filtered_notices):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤—Å–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
    total_sent = 0

    for notice in filtered_notices:
        sent_count = await send_notifications(notice)
        if sent_count > 0:
            total_sent += 1

        # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ –∑–∞–∫—É–ø–∫–∞–º–∏
        await asyncio.sleep(2)

    return total_sent


async def scrape_mimz_async():
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫—Ä–∞–ø–∏–Ω–≥–∞ –ú–ò–ú–ó —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π"""

    notices_data = []
    current_page = 1
    today = date.today()
    today_formatted = today.strftime("%d.%m.%Y")
    should_continue = True

    if platform.system() == "Windows":
        chrome_paths = [
            "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
            "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
            os.path.expanduser("~\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe")
            ]
    else:  # Linux/macOS
        chrome_paths = [
            "/usr/bin/google-chrome",
            "/usr/bin/chromium-browser",
            "/usr/bin/chromium",
            "/snap/bin/chromium",
            "/usr/bin/google-chrome-stable",
            "/opt/google/chrome/chrome",
            "/usr/local/bin/chrome",
            "/usr/local/bin/chromium"
            ]

    chrome_path = None
    for path in chrome_paths:
        if os.path.exists(path):
            chrome_path = path
            break

    if not chrome_path:
        logger.error("Chrome –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return []

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            executable_path=chrome_path
            )
        context = await browser.new_context(ignore_https_errors=True)
        page = await context.new_page()

        async def handle_response(response):
            nonlocal notices_data
            if "NoticesJson" in response.url:
                try:
                    data = await response.json()
                    page_notices = []
                    if isinstance(data, list):
                        page_notices = data
                    elif isinstance(data, dict):
                        if 'data' in data:
                            page_notices = data['data']
                        elif 'items' in data:
                            page_notices = data['items']
                        elif 'notices' in data:
                            page_notices = data['notices']
                        else:
                            page_notices = [data]

                    notices_data.extend(page_notices)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")

        page.on("response", handle_response)

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
        await page.goto("https://mimz.admoblkaluga.ru/GzwSP/NoticesGrid")
        await page.wait_for_load_state("networkidle")
        await page.wait_for_timeout(3000)

        while should_continue:
            try:
                await page.wait_for_timeout(2000)

                publication_date_found = False
                dates_on_page = []

                try:
                    date_captions = await page.query_selector_all("span.caption:has-text('–î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏')")

                    for i, caption in enumerate(date_captions):
                        try:
                            parent_td = await caption.query_selector("xpath=..")
                            if parent_td:
                                spans_in_td = await parent_td.query_selector_all("span")

                                for span in spans_in_td:
                                    # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: await —Ç–æ–ª—å–∫–æ –¥–ª—è async –º–µ—Ç–æ–¥–∞
                                    span_text_raw = await span.inner_text()
                                    span_text = span_text_raw.strip()

                                    date_match = re.match(r'^(\d{1,2})\.(\d{1,2})\.(\d{4})$', span_text)
                                    if date_match:
                                        day, month, year = map(int, date_match.groups())
                                        try:
                                            parsed_date = date(year, month, day)
                                            dates_on_page.append(parsed_date)
                                            if parsed_date == today:
                                                publication_date_found = True
                                        except ValueError:
                                            continue
                        except Exception as block_error:
                            logger.error(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–ª–æ–∫–∞ –¥–∞—Ç—ã {i + 1}: {block_error}")
                            continue

                except Exception as search_error:
                    logger.error(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –±–ª–æ–∫–æ–≤ –¥–∞—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {search_error}")

                # –õ–æ–≥–∏–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: –µ—Å–ª–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–µ—Ç —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏—Ö –¥–∞—Ç
                if not publication_date_found:
                    if dates_on_page and all(d < today for d in dates_on_page):
                        break

            except Exception as e:
                logger.error(f"‚ö†–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –¥–∞—Ç: {e}")

            # –ü–æ–∏—Å–∫ –∫–Ω–æ–ø–∫–∏ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            next_button = None
            try:
                next_button = await page.query_selector("span.page.next:not(:has(span:text-is(' ')))")

                if not next_button:
                    next_page_selector = f"span.page[value='{current_page}']:not(.active)"
                    next_button = await page.query_selector(next_page_selector)

                if not next_button:
                    active_page = await page.query_selector("span.page.active")
                    if active_page:
                        active_value = await active_page.get_attribute("value")
                        if active_value is not None:
                            next_value = int(active_value) + 1
                            next_button = await page.query_selector(f"span.page[value='{next_value}']")

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∫–Ω–æ–ø–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏: {e}")

            if not next_button:
                break

            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
            try:
                await next_button.click()
                await page.wait_for_load_state("networkidle")
                await page.wait_for_timeout(3000)

                # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –¥–æ–±–∞–≤–∏—Ç—å await
                new_active = await page.query_selector("span.page.active")
                if new_active:
                    new_active_value = await new_active.get_attribute("value")
                    if new_active_value:
                        actual_page = int(new_active_value) + 1
                        current_page = actual_page
                    else:
                        current_page += 1
                else:
                    current_page += 1

                await page.wait_for_timeout(2000)

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É: {e}")
                break

            if current_page > 50:
                break

    # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–π –¥–∞—Ç–µ (–≤–Ω–µ –±–ª–æ–∫–∞ async with)
    today_notices = []
    today_str = today.strftime("%d.%m.%Y")

    for notice in notices_data:
        if 'pub_date' in notice and notice['pub_date'] == today_str:
            today_notices.append(notice)

    return today_notices


async def periodic_check_mimz():

    while True:
        try:

            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
            keywords = load_keywords()

            # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∫—Ä–∞–ø–∏–Ω–≥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            # –í—ã–ø–æ–ª–Ω—è–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å–∫—Ä–∞–ø–∏–Ω–≥
            notices_data = await scrape_mimz_async()

            if notices_data:

                today_notices = filter_by_today_date(notices_data)
                if not today_notices:
                    logger.info("–ù–µ—Ç –∑–∞–∫—É–ø–æ–∫ –∑–∞ —Å–µ–≥–æ–¥–Ω—è—à–Ω—é—é –¥–∞—Ç—É")
                else:

                    filtered_notices, found_count = await filter_notices(notices_data, keywords)

                    if filtered_notices:
                        await send_all_filtered_notices(filtered_notices)
                    else:
                        logger.info("–ù–µ—Ç –Ω–æ–≤—ã—Ö –∑–∞–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
            else:
                logger.info("–î–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã")

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ú–ò–ú–ó: {e}")

        logger.info("–°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ú–ò–ú–ó —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç...")
        await asyncio.sleep(300)


